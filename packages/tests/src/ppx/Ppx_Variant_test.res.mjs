// Generated by ReScript, PLEASE EDIT WITH CARE

import * as U from "../utils/U.res.mjs";
import Ava from "ava";
import * as S$RescriptSchema from "rescript-schema/src/S.res.mjs";

let variantSchema = S$RescriptSchema.union([
  S$RescriptSchema.literal("One"),
  S$RescriptSchema.literal("Two")
]);

Ava("Variant", t => U.assertEqualSchemas(t, variantSchema, S$RescriptSchema.union([
  S$RescriptSchema.literal("One"),
  S$RescriptSchema.literal("Two")
]), undefined));

let variantWithSingleItemSchema = S$RescriptSchema.literal("Single");

Ava("Variant with single item becomes a literal schema of the item", t => U.assertEqualSchemas(t, variantWithSingleItemSchema, S$RescriptSchema.literal("Single"), undefined));

let variantWithAliasSchema = S$RescriptSchema.union([
  S$RescriptSchema.literal("하나"),
  S$RescriptSchema.literal("Two")
]);

Ava("Variant with partial @as usage", t => U.assertEqualSchemas(t, variantWithAliasSchema, S$RescriptSchema.union([
  S$RescriptSchema.literal("하나"),
  S$RescriptSchema.literal("Two")
]), undefined));

let variantWithPayloadsSchema = S$RescriptSchema.union([
  S$RescriptSchema.literal("Constant"),
  S$RescriptSchema.schema(s => ({
    TAG: "SinglePayload",
    _0: s.m(S$RescriptSchema.int)
  })),
  S$RescriptSchema.schema(s => ({
    TAG: "TuplePayload",
    _0: s.m(S$RescriptSchema.int),
    _1: s.m(S$RescriptSchema.string)
  })),
  S$RescriptSchema.schema(s => ({
    TAG: "RecordPayload",
    foo: s.m(S$RescriptSchema.float)
  }))
]);

Ava("Variant with payloads", t => U.assertEqualSchemas(t, variantWithPayloadsSchema, S$RescriptSchema.union([
  S$RescriptSchema.literal("Constant"),
  S$RescriptSchema.schema(s => ({
    TAG: "SinglePayload",
    _0: s.m(S$RescriptSchema.int)
  })),
  S$RescriptSchema.schema(s => ({
    TAG: "TuplePayload",
    _0: s.m(S$RescriptSchema.int),
    _1: s.m(S$RescriptSchema.string)
  })),
  S$RescriptSchema.schema(s => ({
    TAG: "RecordPayload",
    foo: s.m(S$RescriptSchema.float)
  }))
]), undefined));

let unboxedVariantSchema = S$RescriptSchema.union([
  S$RescriptSchema.literal("Constant"),
  S$RescriptSchema.schema(s => (s.m(S$RescriptSchema.int))),
  S$RescriptSchema.schema(s => (s.m(S$RescriptSchema.string)))
]);

Ava("Unboxed variant", t => U.assertEqualSchemas(t, unboxedVariantSchema, S$RescriptSchema.union([
  S$RescriptSchema.literal("Constant"),
  S$RescriptSchema.schema(s => (s.m(S$RescriptSchema.int))),
  S$RescriptSchema.schema(s => (s.m(S$RescriptSchema.string)))
]), undefined));

let taggedVariantSchema = S$RescriptSchema.union([
  S$RescriptSchema.schema(s => ({
    kind: "circle",
    radius: s.m(S$RescriptSchema.float)
  })),
  S$RescriptSchema.schema(s => ({
    kind: "square",
    x: s.m(S$RescriptSchema.float)
  })),
  S$RescriptSchema.schema(s => ({
    kind: "triangle",
    x: s.m(S$RescriptSchema.float),
    y: s.m(S$RescriptSchema.float)
  }))
]);

Ava("Tagged variant", t => U.assertEqualSchemas(t, taggedVariantSchema, S$RescriptSchema.union([
  S$RescriptSchema.schema(s => ({
    kind: "circle",
    radius: s.m(S$RescriptSchema.float)
  })),
  S$RescriptSchema.schema(s => ({
    kind: "square",
    x: s.m(S$RescriptSchema.float)
  })),
  S$RescriptSchema.schema(s => ({
    kind: "triangle",
    x: s.m(S$RescriptSchema.float),
    y: s.m(S$RescriptSchema.float)
  }))
]), undefined));

let taggedInlinedAliasSchema = S$RescriptSchema.union([
  S$RescriptSchema.schema(s => ({
    type: "Foo",
    Foo: s.m(S$RescriptSchema.string)
  })),
  S$RescriptSchema.schema(s => ({
    type: "Bar",
    Bar: s.m(S$RescriptSchema.string)
  }))
]);

Ava("Tagged variant with inlined alias", t => U.assertEqualSchemas(t, taggedInlinedAliasSchema, S$RescriptSchema.union([
  S$RescriptSchema.schema(s => ({
    type: "Foo",
    Foo: s.m(S$RescriptSchema.string)
  })),
  S$RescriptSchema.schema(s => ({
    type: "Bar",
    Bar: s.m(S$RescriptSchema.string)
  }))
]), undefined));

export {
  variantSchema,
  variantWithSingleItemSchema,
  variantWithAliasSchema,
  variantWithPayloadsSchema,
  unboxedVariantSchema,
  taggedVariantSchema,
  taggedInlinedAliasSchema,
}
/* variantSchema Not a pure module */
