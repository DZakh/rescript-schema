// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Primitive_option from "rescript/lib/es6/Primitive_option.js";
import * as S$RescriptSchema from "rescript-schema/src/S.res.mjs";
import * as Primitive_exceptions from "rescript/lib/es6/Primitive_exceptions.js";

function unsafeGetVariantPayload(variant) {
  return variant._0;
}

let Test = /* @__PURE__ */Primitive_exceptions.create("U.Test");

function raiseTestException() {
  throw {
    RE_EXN_ID: Test,
    Error: new Error()
  };
}

function error(param) {
  let tmp;
  switch (param.operation) {
    case "Parse" :
      tmp = S$RescriptSchema.Flag.typeValidation;
      break;
    case "ParseAsync" :
      tmp = S$RescriptSchema.Flag.typeValidation | S$RescriptSchema.Flag.async;
      break;
    case "ReverseConvertToJson" :
      tmp = S$RescriptSchema.Flag.reverse | S$RescriptSchema.Flag.jsonableOutput;
      break;
    case "ReverseParse" :
      tmp = S$RescriptSchema.Flag.reverse | S$RescriptSchema.Flag.typeValidation;
      break;
    case "ReverseConvert" :
      tmp = S$RescriptSchema.Flag.reverse;
      break;
    case "Assert" :
      tmp = S$RescriptSchema.Flag.typeValidation | S$RescriptSchema.Flag.assertOutput;
      break;
  }
  return S$RescriptSchema.$$Error.make(param.code, tmp, param.path);
}

function assertThrowsTestException(t, fn, message, param) {
  try {
    fn();
    return t.fail("Didn't throw");
  } catch (raw_exn) {
    let exn = Primitive_exceptions.internalToException(raw_exn);
    if (exn.RE_EXN_ID === Test) {
      t.pass(message !== undefined ? Primitive_option.valFromOption(message) : undefined);
      return;
    } else {
      return t.fail("Thrown another exception");
    }
  }
}

function assertRaised(t, cb, errorPayload) {
  let any;
  try {
    any = cb();
  } catch (raw_err) {
    let err = Primitive_exceptions.internalToException(raw_err);
    if (err.RE_EXN_ID === S$RescriptSchema.Raised) {
      t.is(S$RescriptSchema.$$Error.message(err._1), S$RescriptSchema.$$Error.message(error(errorPayload)), undefined);
      return;
    }
    throw err;
  }
  t.fail("Asserted result is not Error. Recieved: " + JSON.stringify(any));
}

async function assertRaisedAsync(t, cb, errorPayload) {
  let any;
  try {
    any = await cb();
  } catch (raw_err) {
    let err = Primitive_exceptions.internalToException(raw_err);
    if (err.RE_EXN_ID === S$RescriptSchema.Raised) {
      t.is(S$RescriptSchema.$$Error.message(err._1), S$RescriptSchema.$$Error.message(error(errorPayload)), undefined);
      return;
    }
    throw err;
  }
  return t.fail("Asserted result is not Error. Recieved: " + JSON.stringify(any));
}

function getCompiledCodeString(schema, op) {
  return (
    op === "Parse" || op === "ParseAsync" ? (
        op === "ParseAsync" || S$RescriptSchema.isAsync(schema) ? S$RescriptSchema.compile(schema, "Any", "Output", "Async", true) : S$RescriptSchema.compile(schema, "Any", "Output", "Sync", true)
      ) : (
        op === "ReverseConvertToJson" ? S$RescriptSchema.compile(schema, "Output", "Json", "Sync", false) : (
            op === "ReverseConvert" ? S$RescriptSchema.compile(schema, "Output", "Input", "Sync", false) : (
                op === "Convert" ? S$RescriptSchema.compile(schema, "Any", "Output", "Sync", false) : (
                    op === "Assert" ? S$RescriptSchema.compile(schema, "Any", "Assert", "Sync", true) : (
                        op === "ReverseParse" ? S$RescriptSchema.compile(schema, "Output", "Input", "Sync", true) : S$RescriptSchema.compile(schema, "Output", "Input", "Async", false)
                      )
                  )
              )
          )
      )
  ).toString();
}

function cleanUpSchema(schema) {
  let $$new = {};
  Object.entries(schema).forEach(param => {
    let value = param[1];
    let key = param[0];
    switch (key) {
      case "advanced" :
      case "c" :
      case "i" :
      case "k" :
      case "of" :
      case "p" :
        return;
      default:
        if (typeof value === "function") {
          return;
        } else {
          if (typeof value === "object" && value !== null) {
            $$new[key] = cleanUpSchema(value);
          } else {
            $$new[key] = value;
          }
          return;
        }
    }
  });
  return $$new;
}

function unsafeAssertEqualSchemas(t, s1, s2, message) {
  t.deepEqual(cleanUpSchema(s1), cleanUpSchema(s2), message !== undefined ? Primitive_option.valFromOption(message) : undefined);
}

function assertCompiledCode(t, schema, op, code, message) {
  t.is(getCompiledCodeString(schema, op), code, message !== undefined ? Primitive_option.valFromOption(message) : undefined);
}

function assertCompiledCodeIsNoop(t, schema, op, message) {
  assertCompiledCode(t, schema, op, "function noopOperation(i) {\n  return i;\n}", message);
}

function assertReverseParsesBack(t, schema, value) {
  t.deepEqual(S$RescriptSchema.parseOrThrow(S$RescriptSchema.reverseConvertOrThrow(value, schema), schema), value, undefined);
}

let assertEqualSchemas = unsafeAssertEqualSchemas;

export {
  unsafeGetVariantPayload,
  Test,
  raiseTestException,
  error,
  assertThrowsTestException,
  assertRaised,
  assertRaisedAsync,
  getCompiledCodeString,
  cleanUpSchema,
  unsafeAssertEqualSchemas,
  assertCompiledCode,
  assertCompiledCodeIsNoop,
  assertEqualSchemas,
  assertReverseParsesBack,
}
/* S-RescriptSchema Not a pure module */
