// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Js_dict = require("rescript/lib/js/js_dict.js");
var Js_json = require("rescript/lib/js/js_json.js");
var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Caml_int64 = require("rescript/lib/js/caml_int64.js");
var Core__JSON = require("@rescript/core/src/Core__JSON.js");
var Core__List = require("@rescript/core/src/Core__List.js");
var Belt_Result = require("rescript/lib/js/belt_Result.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Core__Array = require("@rescript/core/src/Core__Array.js");
var Core__Result = require("@rescript/core/src/Core__Result.js");

function error(path, message, value) {
  var path$1 = path !== undefined ? path : "";
  return {
          TAG: /* Error */1,
          _0: {
            path: path$1,
            message: message,
            value: value
          }
        };
}

function stringToJson(s) {
  return s;
}

function stringFromJson(j) {
  var s = Core__JSON.Decode.string(j);
  if (s !== undefined) {
    return {
            TAG: /* Ok */0,
            _0: s
          };
  } else {
    return {
            TAG: /* Error */1,
            _0: {
              path: "",
              message: "Not a string",
              value: j
            }
          };
  }
}

function intToJson(i) {
  return i;
}

function intFromJson(j) {
  var f = Core__JSON.Decode.$$float(j);
  if (f !== undefined) {
    if (Math.floor(f) === f) {
      return {
              TAG: /* Ok */0,
              _0: Math.floor(f) | 0
            };
    } else {
      return {
              TAG: /* Error */1,
              _0: {
                path: "",
                message: "Not an integer",
                value: j
              }
            };
    }
  } else {
    return {
            TAG: /* Error */1,
            _0: {
              path: "",
              message: "Not a number",
              value: j
            }
          };
  }
}

var int64ToJson = Caml_int64.float_of_bits;

function int64FromJson(j) {
  var n = Core__JSON.Decode.$$float(j);
  if (n !== undefined) {
    return {
            TAG: /* Ok */0,
            _0: Caml_int64.bits_of_float(n)
          };
  } else {
    return error(undefined, "Not a number", j);
  }
}

var int64ToJsonUnsafe = Caml_int64.to_float;

function int64FromJsonUnsafe(j) {
  var n = Core__JSON.Decode.$$float(j);
  if (n !== undefined) {
    return {
            TAG: /* Ok */0,
            _0: Caml_int64.of_float(n)
          };
  } else {
    return error(undefined, "Not a number", j);
  }
}

function floatToJson(v) {
  return v;
}

function floatFromJson(j) {
  var f = Core__JSON.Decode.$$float(j);
  if (f !== undefined) {
    return {
            TAG: /* Ok */0,
            _0: f
          };
  } else {
    return {
            TAG: /* Error */1,
            _0: {
              path: "",
              message: "Not a number",
              value: j
            }
          };
  }
}

function boolToJson(v) {
  return v;
}

function boolFromJson(j) {
  var b = Core__JSON.Decode.$$float(j);
  if (b !== undefined) {
    return {
            TAG: /* Ok */0,
            _0: b
          };
  } else {
    return {
            TAG: /* Error */1,
            _0: {
              path: "",
              message: "Not a boolean",
              value: j
            }
          };
  }
}

function unitToJson(param) {
  return 0.0;
}

function unitFromJson(param) {
  return {
          TAG: /* Ok */0,
          _0: undefined
        };
}

function arrayToJson(encoder, arr) {
  return arr.map(encoder);
}

function arrayFromJson(decoder, json) {
  var arr = Core__JSON.Decode.array(json);
  if (arr !== undefined) {
    return Core__Array.reduceWithIndex(arr, {
                TAG: /* Ok */0,
                _0: []
              }, (function (acc, jsonI, i) {
                  var match = Curry._1(decoder, jsonI);
                  if (acc.TAG !== /* Ok */0) {
                    return acc;
                  }
                  if (match.TAG === /* Ok */0) {
                    return {
                            TAG: /* Ok */0,
                            _0: acc._0.concat([match._0])
                          };
                  }
                  var error = match._0;
                  return {
                          TAG: /* Error */1,
                          _0: {
                            path: "[" + (String(i) + ("]" + error.path)),
                            message: error.message,
                            value: error.value
                          }
                        };
                }));
  } else {
    return {
            TAG: /* Error */1,
            _0: {
              path: "",
              message: "Not an array",
              value: json
            }
          };
  }
}

function listToJson(encoder, list) {
  return Core__List.toArray(list).map(encoder);
}

function listFromJson(decoder, json) {
  return Core__Result.map(arrayFromJson(decoder, json), Core__List.fromArray);
}

function optionToJson(encoder, opt) {
  if (opt !== undefined) {
    return Curry._1(encoder, Caml_option.valFromOption(opt));
  } else {
    return null;
  }
}

function filterOptional(arr) {
  var __x = Belt_Array.keep(arr, (function (param) {
          return !(param[1] && Caml_obj.equal(param[2], null));
        }));
  return Belt_Array.map(__x, (function (param) {
                return [
                        param[0],
                        param[2]
                      ];
              }));
}

function optionFromJson(decoder, json) {
  var match = Js_json.decodeNull(json);
  if (match !== undefined) {
    return {
            TAG: /* Ok */0,
            _0: undefined
          };
  }
  var __x = Curry._1(decoder, json);
  return Belt_Result.map(__x, (function (v) {
                return Caml_option.some(v);
              }));
}

function resultToJson(okEncoder, errorEncoder, result) {
  if (result.TAG === /* Ok */0) {
    return [
            "Ok",
            Curry._1(okEncoder, result._0)
          ];
  } else {
    return [
            "Error",
            Curry._1(errorEncoder, result._0)
          ];
  }
}

function resultFromJson(okDecoder, errorDecoder, json) {
  var match = Js_json.decodeArray(json);
  if (match === undefined) {
    return error(undefined, "Not an array", json);
  }
  if (match.length !== 2) {
    return error(undefined, "Expected exactly 2 values in array", json);
  }
  var variantConstructorId = match[0];
  var payload = match[1];
  var match$1 = Js_json.decodeString(variantConstructorId);
  if (match$1 === undefined) {
    return error(undefined, "Not a string", variantConstructorId);
  }
  switch (match$1) {
    case "Error" :
        var v = Curry._1(errorDecoder, payload);
        if (v.TAG === /* Ok */0) {
          return {
                  TAG: /* Ok */0,
                  _0: {
                    TAG: /* Error */1,
                    _0: v._0
                  }
                };
        } else {
          return {
                  TAG: /* Error */1,
                  _0: v._0
                };
        }
    case "Ok" :
        return Belt_Result.map(Curry._1(okDecoder, payload), (function (v) {
                      return {
                              TAG: /* Ok */0,
                              _0: v
                            };
                    }));
    default:
      return error(undefined, "Expected either \"Ok\" or \"Error\"", variantConstructorId);
  }
}

function dictToJson(encoder, dict) {
  return Js_dict.map(Curry.__1(encoder), dict);
}

function dictFromJson(decoder, json) {
  var dict = Js_json.decodeObject(json);
  if (dict !== undefined) {
    return Belt_Array.reduce(Js_dict.entries(Caml_option.valFromOption(dict)), {
                TAG: /* Ok */0,
                _0: {}
              }, (function (acc, param) {
                  var key = param[0];
                  var match = Curry._1(decoder, param[1]);
                  if (acc.TAG !== /* Ok */0) {
                    return acc;
                  }
                  var prev = acc._0;
                  if (match.TAG === /* Ok */0) {
                    prev[key] = match._0;
                    return {
                            TAG: /* Ok */0,
                            _0: prev
                          };
                  }
                  var error = match._0;
                  return {
                          TAG: /* Error */1,
                          _0: {
                            path: "." + (key + error.path),
                            message: error.message,
                            value: error.value
                          }
                        };
                }));
  } else {
    return {
            TAG: /* Error */1,
            _0: {
              path: "",
              message: "Not a dict",
              value: json
            }
          };
  }
}

exports.error = error;
exports.stringToJson = stringToJson;
exports.stringFromJson = stringFromJson;
exports.intToJson = intToJson;
exports.intFromJson = intFromJson;
exports.int64ToJson = int64ToJson;
exports.int64FromJson = int64FromJson;
exports.int64ToJsonUnsafe = int64ToJsonUnsafe;
exports.int64FromJsonUnsafe = int64FromJsonUnsafe;
exports.floatToJson = floatToJson;
exports.floatFromJson = floatFromJson;
exports.boolToJson = boolToJson;
exports.boolFromJson = boolFromJson;
exports.unitToJson = unitToJson;
exports.unitFromJson = unitFromJson;
exports.arrayToJson = arrayToJson;
exports.arrayFromJson = arrayFromJson;
exports.listToJson = listToJson;
exports.listFromJson = listFromJson;
exports.optionToJson = optionToJson;
exports.filterOptional = filterOptional;
exports.optionFromJson = optionFromJson;
exports.resultToJson = resultToJson;
exports.resultFromJson = resultFromJson;
exports.dictToJson = dictToJson;
exports.dictFromJson = dictFromJson;
/* No side effect */
